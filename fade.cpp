//=============================================================================
//
// フェード処理 [fade.cpp]
// Author : 
//
//=============================================================================
#include "fade.h"
//#include "texture.h"
//#include "sprite.h"
#include "renderer.h"
#include "polygon2D.h"

//*****************************************************************************
// マクロ定義
//*****************************************************************************
#define	FADE_RATE					(0.02f)			// フェード係数


//*****************************************************************************
// プロトタイプ宣言
//*****************************************************************************


//*****************************************************************************
// グローバル変数
//*****************************************************************************
static int			g_TextureNo;				// テクスチャ番号

static FADE_STATE	g_FadeState = FADE_NONE;	// フェードの状態
static D3DXCOLOR	g_Color;					// フェードのカラー
//static SCENE		g_SceneNext;				// 次のシーン


//=============================================================================
// 初期化処理
//=============================================================================
HRESULT Fade::InitFade(void)
{
	//テクスチャ生成
	g_TextureNo = LoadTexture((char*)"data/TEXTURE/fade_white.png");

	//初期化
	g_FadeState  = FADE_NONE;
	g_SceneNext = SCENE_NONE;
	g_Color = D3DXCOLOR(1.0, 1.0, 1.0, 1.0);

	return S_OK;
}

//=============================================================================
// 終了処理
//=============================================================================
void Fade::UninitFade(void)
{

}

//=============================================================================
// 更新処理
//=============================================================================
void Fade::UpdateFade(void)
{
	// フェード処理中
	if (g_FadeState != FADE_NONE)
	{
		if (g_FadeState == FADE_OUT)
		{// フェードアウト処理
			g_Color.a += FADE_RATE;		// α値を加算して画面を消していく

			if (g_Color.a >= 1.0f)
			{
				// フェードイン処理に切り替え
				g_Color.a = 1.0f;
				g_FadeState = FADE_IN;

				// モードを設定
				SetScene(g_SceneNext);
			}
		}
		else if (g_FadeState == FADE_IN)
		{// フェードイン処理
			g_Color.a -= FADE_RATE;		// α値を減算して画面を浮き上がらせる
			if (g_Color.a <= 0.0f)
			{
				// フェード処理終了
				g_Color.a = 0.0f;
				g_FadeState = FADE_NONE;
			}

		}
	}
}

//=============================================================================
// 描画処理
//=============================================================================
void Fade::DrawFade(void)
{
	// フェード処理をしていないのなら描画しない
	if (g_FadeState == FADE_NONE)
		return;	

	// １枚のポリゴンの頂点とテクスチャ座標を設定
	DrawSpriteColor(g_TextureNo, SCREEN_WIDTH/2, SCREEN_HEIGHT/2, SCREEN_WIDTH, SCREEN_HEIGHT, 0.0f, 0.0f, 1.0f, 1.0f, g_Color);
}



/*------------------------------------------------------------------------------
   フェード処理の状況を返す関数
------------------------------------------------------------------------------*/
FADE_STATE Fade::GetFadeState(void)
{

	return g_FadeState;
}

/*------------------------------------------------------------------------------
   フェードカラー設定する関数
------------------------------------------------------------------------------*/
void Fade::SetFadeColor(float r, float g, float b)
{
	g_Color = XMFLOAT4(r, g, b, 1.0f);
}

